# CH01 开始

### 编译运行程序

程序文件通常称为源文件(source file)，不同编译器使用不同的后缀命名约定，常见的包括：.cc/.cxx/.cpp/.cp/.C。   

##### 命令行运行编译器

可以通过命令`$ CC prog1.cc`来编译（CC为编译器程序名）。Windows会将可执行文件命名为`prog1.exe`，UNIX系统通常将可执行文件命名为`a.out`。运行程序只需在命令行输入`$ prog1`(windows)或`$ ./a.out`(UNIX)。   
访问main方法的返回值依赖于系统。UNIX系统中，通过`$ echo $?`来获得返回值；而Windows系统通过`$ echo %ERROELEVEL%`查看状态。
常用编译器有GNU和VS。运行GNU编译器的命令是`$ g++ -o prog1 prog1.cc`，`-o prog1`指定了生成可执行文件的名字，UNIX系统中无后缀，Win系统中会有后缀`.exe`。   

### 流读写
标准库`iostream`包含两个基础类型`istream`和`ostream`，分别表示输入流和输出流。一个流就是一个字符序列，使用IO设备读出或写入IO设的。“流”（stream）的意思是，随着时间的推移，字符是顺序生成或消耗的。   

###### iostream
标准库定义了4个IO对象：      
- `cin`是`istream`对象，称为标准输入。     
- `cout`是`ostream`对象，称为标准输出。  
- `cerr`是`ostream`对象，称为标准错误，用来输出警告和错误信息以及其他不属于程序正常逻辑的输出内容。默认情况下，写到`cerr`的数据是不缓冲的。  
- `clog`是`ostream`对象，用来输出程序运行时的一般性信息。 默认情况下写入`clog`的数据是被缓冲的，`clog`通常用于报告程序的执行信息，存入一个日志文件中。

```
std::cout <<  "Hello,world!" << std::endl ;
```
上段代码中， *endl* 称为 *操纵符(manipulator)*，写入 *endl* 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。   
读写缓冲区的动作与程序中的动作是无关的，显式刷新输出缓冲以便强制将缓冲区中数据写入输出设备。默认情况下，读`cin`会刷新`cout`；程序非正常中止也会刷新`cout`。
```  
std::cin >> v1 >> v2;      
/*
 *等价于(std::cin >> v1) >> v2;     
 *也等价于  std::cin >> v1;     
 *         std:cin >> v2;
 */
```   
```
  int val = 0 ;
  while( std::cin >> val){
    std::cout << val * val << std::endl;
  }
```
当使用一个`istream`对象作为条件时，效果是检测流的状态。如果流是有效的，即流未遇到错误，则检测成功；当遇到 *文件结束符(end-of-file)* 或无效输入(如上段代码读入的值不是整数)时，`istream`状态会变为无效，会使条件判断为假。

###### 文件结束符

从键盘向程序输入数据时，不同操作系统指示文件结束的约定是不同的。Win系统输入文件结束符的方法是`Ctrl+Z`，然后按`Enter`或`Return`键。UNIX系统，包括MAC OS X系统，使用`Ctrl+D`。   

### 注释

C++注释共两种，单行注释(//开头)和界定符对注释(/\* ... \*/)。注释界定符不能嵌套。当注释界定符跨行时，最好能显示指出其内部的程序行都属于多行注释的一部分，因此推荐使用风格为：   
```
/*   
 * ...   
 * ...   
 * ...   
 */   
```
